{"version":3,"file":"dnd-kit-sortable-tree.cjs.production.min.js","sources":["../node_modules/style-inject/dist/style-inject.es.js","../src/ui/simple/SimpleTreeItemWrapper.tsx","../src/ui/folder/FolderTreeItemWrapper.tsx","../src/utilities.ts","../src/SortableTreeItem.tsx","../src/SortableTree.tsx","../src/SortingStrategy.ts"],"sourcesContent":["function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","import clsx from 'clsx';\r\nimport React, { forwardRef } from 'react';\r\nimport type { TreeItemComponentProps } from '../../types';\r\nimport './SimpleTreeItemWrapper.css';\r\n\r\nexport const SimpleTreeItemWrapper = forwardRef<\r\n  HTMLDivElement,\r\n  React.PropsWithChildren<TreeItemComponentProps<{}>>\r\n>((props, ref) => {\r\n  const {\r\n    clone,\r\n    depth,\r\n    disableSelection,\r\n    disableInteraction,\r\n    disableSorting,\r\n    ghost,\r\n    handleProps,\r\n    indentationWidth,\r\n    indicator,\r\n    collapsed,\r\n    onCollapse,\r\n    onRemove,\r\n    item,\r\n    wrapperRef,\r\n    style,\r\n    hideCollapseButton,\r\n    childCount,\r\n    manualDrag,\r\n    showDragHandle,\r\n    disableCollapseOnItemClick,\r\n    isLast,\r\n    parent,\r\n    className,\r\n    contentClassName,\r\n    isOver,\r\n    isOverParent,\r\n    ...rest\r\n  } = props;\r\n\r\n  return (\r\n    <li\r\n      ref={wrapperRef}\r\n      {...rest}\r\n      className={clsx(\r\n        'dnd-sortable-tree_simple_wrapper',\r\n        clone && 'dnd-sortable-tree_simple_clone',\r\n        ghost && 'dnd-sortable-tree_simple_ghost',\r\n        disableSelection && 'dnd-sortable-tree_simple_disable-selection',\r\n        disableInteraction && 'dnd-sortable-tree_simple_disable-interaction',\r\n        className\r\n      )}\r\n      style={{\r\n        ...style,\r\n        paddingLeft: clone ? indentationWidth : indentationWidth * depth,\r\n      }}\r\n    >\r\n      <div\r\n        className={clsx('dnd-sortable-tree_simple_tree-item', contentClassName)}\r\n        ref={ref}\r\n        {...(manualDrag ? undefined : handleProps)}\r\n        onClick={disableCollapseOnItemClick ? undefined : onCollapse}\r\n      >\r\n        {!disableSorting && showDragHandle !== false && (\r\n          <div className={'dnd-sortable-tree_simple_handle'} {...handleProps} />\r\n        )}\r\n        {!manualDrag && !hideCollapseButton && !!onCollapse && !!childCount && (\r\n          <button\r\n            onClick={(e) => {\r\n              if (!disableCollapseOnItemClick) {\r\n                return;\r\n              }\r\n              e.preventDefault();\r\n              onCollapse?.();\r\n            }}\r\n            className={clsx(\r\n              'dnd-sortable-tree_simple_tree-item-collapse_button',\r\n              collapsed &&\r\n                'dnd-sortable-tree_folder_simple-item-collapse_button-collapsed'\r\n            )}\r\n          />\r\n        )}\r\n        {props.children}\r\n      </div>\r\n    </li>\r\n  );\r\n}) as <T>(\r\n  p: React.PropsWithChildren<\r\n    TreeItemComponentProps<T> & React.RefAttributes<HTMLDivElement>\r\n  >\r\n) => React.ReactElement;\r\n","import clsx from 'clsx';\r\nimport React, { forwardRef } from 'react';\r\nimport type { TreeItemComponentProps, FlattenedItem } from '../../types';\r\nimport './FolderTreeItemWrapper.css';\r\n\r\nfunction flattenParents<T>(\r\n  parent: FlattenedItem<T> | null\r\n): FlattenedItem<T>[] {\r\n  if (!parent) return [];\r\n  return [...flattenParents(parent.parent), parent];\r\n}\r\n\r\nexport const FolderTreeItemWrapper = forwardRef<\r\n  HTMLDivElement,\r\n  React.PropsWithChildren<TreeItemComponentProps<{}>>\r\n>((props, ref) => {\r\n  const {\r\n    clone,\r\n    depth,\r\n    disableSelection,\r\n    disableInteraction,\r\n    disableSorting,\r\n    ghost,\r\n    handleProps,\r\n    indentationWidth,\r\n    indicator,\r\n    collapsed,\r\n    onCollapse,\r\n    onRemove,\r\n    item,\r\n    wrapperRef,\r\n    style,\r\n    isLast,\r\n    parent,\r\n    hideCollapseButton,\r\n    childCount,\r\n    manualDrag,\r\n    showDragHandle,\r\n    disableCollapseOnItemClick,\r\n    className,\r\n    contentClassName,\r\n    isOver,\r\n    isOverParent,\r\n    ...rest\r\n  } = props;\r\n\r\n  const flattenedParents = flattenParents(parent);\r\n  return (\r\n    <li\r\n      {...rest}\r\n      className={clsx(\r\n        'dnd-sortable-tree_folder_wrapper',\r\n        clone && 'dnd-sortable-tree_folder_clone',\r\n        ghost && 'dnd-sortable-tree_folder_ghost',\r\n        disableSelection && 'dnd-sortable-tree_folder_disable-selection',\r\n        disableInteraction && 'dnd-sortable-tree_folder_disable-interaction',\r\n        className\r\n      )}\r\n      ref={wrapperRef}\r\n      style={style}\r\n    >\r\n      {flattenedParents.map((item) => (\r\n        <div\r\n          key={item.id}\r\n          className={\r\n            item.isLast\r\n              ? 'dnd-sortable-tree_folder_line-last'\r\n              : 'dnd-sortable-tree_folder_line'\r\n          }\r\n        />\r\n      ))}\r\n      <div\r\n        className={\r\n          isLast\r\n            ? 'dnd-sortable-tree_folder_line-to_self-last'\r\n            : 'dnd-sortable-tree_folder_line-to_self'\r\n        }\r\n      />\r\n      {manualDrag && showDragHandle && !disableSorting && (\r\n        <div className={'dnd-sortable-tree_folder_handle'} {...handleProps} />\r\n      )}\r\n      {!manualDrag && !hideCollapseButton && !!onCollapse && !!childCount && (\r\n        <button\r\n          onClick={(e) => {\r\n            e.preventDefault();\r\n            onCollapse?.();\r\n          }}\r\n          className={clsx(\r\n            'dnd-sortable-tree_folder_tree-item-collapse_button',\r\n            collapsed &&\r\n              'dnd-sortable-tree_folder_tree-item-collapse_button-collapsed'\r\n          )}\r\n        />\r\n      )}\r\n      <div\r\n        className={clsx('dnd-sortable-tree_folder_tree-item', contentClassName)}\r\n        ref={ref}\r\n        {...(manualDrag ? undefined : handleProps)}\r\n        onClick={disableCollapseOnItemClick ? undefined : onCollapse}\r\n      >\r\n        {props.children}\r\n      </div>\r\n    </li>\r\n  );\r\n}) as <T>(\r\n  p: React.PropsWithChildren<\r\n    TreeItemComponentProps<T> & React.RefAttributes<HTMLDivElement>\r\n  >\r\n) => React.ReactElement;\r\n","import { arrayMove } from '@dnd-kit/sortable';\r\n\r\nimport type { FlattenedItem, TreeItem, TreeItems } from './types';\r\nimport { UniqueIdentifier } from '@dnd-kit/core';\r\n\r\nexport const iOS =\r\n  typeof window !== 'undefined'\r\n    ? /iPad|iPhone|iPod/.test(navigator.platform)\r\n    : false;\r\n\r\nfunction getDragDepth(offset: number, indentationWidth: number) {\r\n  return Math.round(offset / indentationWidth);\r\n}\r\n\r\nlet _revertLastChanges = () => {};\r\nexport function getProjection<T>(\r\n  items: FlattenedItem<T>[],\r\n  activeId: UniqueIdentifier | null,\r\n  overId: UniqueIdentifier | null,\r\n  dragOffset: number,\r\n  indentationWidth: number,\r\n  keepGhostInPlace: boolean,\r\n  canRootHaveChildren?: boolean | ((dragItem: FlattenedItem<T>) => boolean)\r\n): {\r\n  depth: number;\r\n  parentId: UniqueIdentifier | null;\r\n  parent: FlattenedItem<T> | null;\r\n  isLast: boolean;\r\n} | null {\r\n  _revertLastChanges();\r\n  _revertLastChanges = () => {};\r\n  if (!activeId || !overId) return null;\r\n\r\n  const overItemIndex = items.findIndex(({ id }) => id === overId);\r\n  const activeItemIndex = items.findIndex(({ id }) => id === activeId);\r\n  const activeItem = items[activeItemIndex];\r\n  if (keepGhostInPlace) {\r\n    let parent: FlattenedItem<T> | null | undefined = items[overItemIndex];\r\n    parent = findParentWhichCanHaveChildren(\r\n      parent,\r\n      activeItem,\r\n      canRootHaveChildren\r\n    );\r\n    if (parent === undefined) return null;\r\n    return {\r\n      depth: parent?.depth ?? 0 + 1,\r\n      parentId: parent?.id ?? null,\r\n      parent: parent,\r\n      isLast: !!parent?.isLast,\r\n    };\r\n  }\r\n  const newItems = arrayMove(items, activeItemIndex, overItemIndex);\r\n  const previousItem = newItems[overItemIndex - 1];\r\n  const nextItem = newItems[overItemIndex + 1];\r\n  const dragDepth = getDragDepth(dragOffset, indentationWidth);\r\n  const projectedDepth = activeItem.depth + dragDepth;\r\n\r\n  let depth = projectedDepth;\r\n  let directParent = findParentWithDepth(depth - 1, previousItem);\r\n  let parent = findParentWhichCanHaveChildren(\r\n    directParent,\r\n    activeItem,\r\n    canRootHaveChildren\r\n  );\r\n  if (parent === undefined) return null;\r\n  const maxDepth = (parent?.depth ?? -1) + 1;\r\n  const minDepth = nextItem?.depth ?? 0;\r\n  if (minDepth > maxDepth) return null;\r\n  if (depth >= maxDepth) {\r\n    depth = maxDepth;\r\n  } else if (depth < minDepth) {\r\n    depth = minDepth;\r\n  }\r\n  const isLast = (nextItem?.depth ?? -1) < depth;\r\n\r\n  if (parent && parent.isLast) {\r\n    _revertLastChanges = () => {\r\n      parent!.isLast = true;\r\n    };\r\n    parent.isLast = false;\r\n  }\r\n  return {\r\n    depth,\r\n    parentId: getParentId(),\r\n    parent,\r\n    isLast,\r\n  };\r\n\r\n  function findParentWithDepth(depth: number, previousItem: FlattenedItem<T>) {\r\n    if (!previousItem) return null;\r\n    while (depth < previousItem.depth) {\r\n      if (previousItem.parent === null) return null;\r\n      previousItem = previousItem.parent;\r\n    }\r\n    return previousItem;\r\n  }\r\n  function findParentWhichCanHaveChildren(\r\n    parent: FlattenedItem<T> | null,\r\n    dragItem: FlattenedItem<T>,\r\n    canRootHaveChildren?: boolean | ((dragItem: FlattenedItem<T>) => boolean)\r\n  ): FlattenedItem<T> | null | undefined {\r\n    if (!parent) {\r\n      const rootCanHaveChildren =\r\n        typeof canRootHaveChildren === 'function'\r\n          ? canRootHaveChildren(dragItem)\r\n          : canRootHaveChildren;\r\n      if (rootCanHaveChildren === false) return undefined;\r\n      return parent;\r\n    }\r\n    const canHaveChildren =\r\n      typeof parent.canHaveChildren === 'function'\r\n        ? parent.canHaveChildren(dragItem)\r\n        : parent.canHaveChildren;\r\n    if (canHaveChildren === false)\r\n      return findParentWhichCanHaveChildren(\r\n        parent.parent,\r\n        activeItem,\r\n        canRootHaveChildren\r\n      );\r\n    return parent;\r\n  }\r\n\r\n  function getParentId() {\r\n    if (depth === 0 || !previousItem) {\r\n      return null;\r\n    }\r\n\r\n    if (depth === previousItem.depth) {\r\n      return previousItem.parentId;\r\n    }\r\n\r\n    if (depth > previousItem.depth) {\r\n      return previousItem.id;\r\n    }\r\n\r\n    const newParent = newItems\r\n      .slice(0, overItemIndex)\r\n      .reverse()\r\n      .find((item) => item.depth === depth)?.parentId;\r\n\r\n    return newParent ?? null;\r\n  }\r\n}\r\n\r\nfunction flatten<T extends Record<string, any>>(\r\n  items: TreeItems<T>,\r\n  parentId: UniqueIdentifier | null = null,\r\n  depth = 0,\r\n  parent: FlattenedItem<T> | null = null\r\n): FlattenedItem<T>[] {\r\n  return items.reduce<FlattenedItem<T>[]>((acc, item, index) => {\r\n    const flattenedItem: FlattenedItem<T> = {\r\n      ...item,\r\n      parentId,\r\n      depth,\r\n      index,\r\n      isLast: items.length === index + 1,\r\n      parent: parent,\r\n    };\r\n    return [\r\n      ...acc,\r\n      flattenedItem,\r\n      ...flatten(item.children ?? [], item.id, depth + 1, flattenedItem),\r\n    ];\r\n  }, []);\r\n}\r\n\r\nexport function flattenTree<T extends Record<string, any>>(\r\n  items: TreeItems<T>\r\n): FlattenedItem<T>[] {\r\n  return flatten(items);\r\n}\r\n\r\nexport function buildTree<T extends Record<string, any>>(\r\n  flattenedItems: FlattenedItem<T>[]\r\n): TreeItems<T> {\r\n  const root: TreeItem<T> = { id: 'root', children: [] } as any;\r\n  const nodes: Record<string, TreeItem<T>> = { [root.id]: root };\r\n  const items = flattenedItems.map((item) => ({ ...item, children: [] }));\r\n\r\n  for (const item of items) {\r\n    const { id } = item;\r\n    const parentId = item.parentId ?? root.id;\r\n    const parent = nodes[parentId] ?? findItem(items, parentId);\r\n    item.parent = null;\r\n    nodes[id] = item;\r\n    parent?.children?.push(item);\r\n  }\r\n\r\n  return root.children ?? [];\r\n}\r\n\r\nexport function findItem<T>(items: TreeItem<T>[], itemId: UniqueIdentifier) {\r\n  return items.find(({ id }) => id === itemId);\r\n}\r\n\r\nexport function findItemDeep<T extends Record<string, any>>(\r\n  items: TreeItems<T>,\r\n  itemId: UniqueIdentifier\r\n): TreeItem<T> | undefined {\r\n  for (const item of items) {\r\n    const { id, children } = item;\r\n\r\n    if (id === itemId) {\r\n      return item;\r\n    }\r\n\r\n    if (children?.length) {\r\n      const child = findItemDeep(children, itemId);\r\n\r\n      if (child) {\r\n        return child;\r\n      }\r\n    }\r\n  }\r\n\r\n  return undefined;\r\n}\r\n\r\nexport function removeItem<T extends Record<string, any>>(\r\n  items: TreeItems<T>,\r\n  id: string\r\n) {\r\n  const newItems = [];\r\n\r\n  for (const item of items) {\r\n    if (item.id === id) {\r\n      continue;\r\n    }\r\n\r\n    if (item.children?.length) {\r\n      item.children = removeItem(item.children, id);\r\n    }\r\n\r\n    newItems.push(item);\r\n  }\r\n\r\n  return newItems;\r\n}\r\n\r\nexport function setProperty<\r\n  TData extends Record<string, any>,\r\n  T extends keyof TreeItem<TData>\r\n>(\r\n  items: TreeItems<TData>,\r\n  id: string,\r\n  property: T,\r\n  setter: (value: TreeItem<TData>[T]) => TreeItem<TData>[T]\r\n) {\r\n  for (const item of items) {\r\n    if (item.id === id) {\r\n      item[property] = setter(item[property]);\r\n      continue;\r\n    }\r\n\r\n    if (item.children?.length) {\r\n      item.children = setProperty(item.children, id, property, setter);\r\n    }\r\n  }\r\n\r\n  return [...items];\r\n}\r\n\r\nfunction countChildren<T>(items: TreeItem<T>[], count = 0): number {\r\n  return items.reduce((acc, { children }) => {\r\n    if (children?.length) {\r\n      return countChildren(children, acc + 1);\r\n    }\r\n\r\n    return acc + 1;\r\n  }, count);\r\n}\r\n\r\nexport function getChildCount<T extends Record<string, any>>(\r\n  items: TreeItems<T>,\r\n  id: UniqueIdentifier\r\n) {\r\n  if (!id) {\r\n    return 0;\r\n  }\r\n\r\n  const item = findItemDeep(items, id);\r\n\r\n  return item ? countChildren(item.children ?? []) : 0;\r\n}\r\n\r\nexport function removeChildrenOf<T>(\r\n  items: FlattenedItem<T>[],\r\n  ids: UniqueIdentifier[]\r\n) {\r\n  const excludeParentIds = [...ids];\r\n\r\n  return items.filter((item) => {\r\n    if (item.parentId && excludeParentIds.includes(item.parentId)) {\r\n      if (item.children?.length) {\r\n        excludeParentIds.push(item.id);\r\n      }\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  });\r\n}\r\n\r\nexport function getIsOverParent<T>(\r\n  parent: FlattenedItem<T> | null,\r\n  overId: UniqueIdentifier\r\n): boolean {\r\n  if (!parent || !overId) return false;\r\n  if (parent.id === overId) return true;\r\n  return getIsOverParent(parent.parent, overId);\r\n}\r\n","import React, { CSSProperties, HTMLAttributes, useMemo } from 'react';\nimport {\n  AnimateLayoutChanges,\n  UseSortableArguments,\n  useSortable,\n} from '@dnd-kit/sortable';\nimport { CSS } from '@dnd-kit/utilities';\n\nimport { getIsOverParent, iOS } from './utilities';\nimport type { FlattenedItem, TreeItem, TreeItemComponentType } from './types';\nimport { UniqueIdentifier } from '@dnd-kit/core';\n\nexport interface TreeItemProps<T> extends HTMLAttributes<HTMLLIElement> {\n  childCount?: number;\n  clone?: boolean;\n  collapsed?: boolean;\n  depth: number;\n  disableInteraction?: boolean;\n  disableSelection?: boolean;\n  ghost?: boolean;\n  handleProps?: any;\n  indicator?: boolean;\n  indentationWidth: number;\n  item: TreeItem<T>;\n  isLast: boolean;\n  parent: FlattenedItem<T> | null;\n  onCollapse?(id: UniqueIdentifier): void;\n\n  onRemove?(id: UniqueIdentifier): void;\n\n  wrapperRef?(node: HTMLLIElement): void;\n}\n\nconst animateLayoutChanges: AnimateLayoutChanges = ({\n  isSorting,\n  isDragging,\n}) => (isSorting || isDragging ? false : true);\n\ntype SortableTreeItemProps<\n  T,\n  TElement extends HTMLElement\n> = TreeItemProps<T> & {\n  id: string;\n  TreeItemComponent: TreeItemComponentType<T, TElement>;\n  disableSorting?: boolean;\n  sortableProps?: Omit<UseSortableArguments, 'id'>;\n  keepGhostInPlace?: boolean;\n};\n\nconst SortableTreeItemNotMemoized = function SortableTreeItem<\n  T,\n  TElement extends HTMLElement\n>({\n  id,\n  depth,\n  isLast,\n  TreeItemComponent,\n  parent,\n  disableSorting,\n  sortableProps,\n  keepGhostInPlace,\n  ...props\n}: SortableTreeItemProps<T, TElement>) {\n  const {\n    attributes,\n    isDragging,\n    isSorting,\n    listeners,\n    setDraggableNodeRef,\n    setDroppableNodeRef,\n    transform,\n    transition,\n    isOver,\n    over,\n  } = useSortable({\n    id,\n    animateLayoutChanges,\n    disabled: disableSorting,\n    ...sortableProps,\n  });\n  const isOverParent = useMemo(\n    () => !!over?.id && getIsOverParent(parent, over.id),\n    [over?.id]\n  );\n  const style: CSSProperties = {\n    transform: CSS.Translate.toString(transform),\n    transition: transition ?? undefined,\n  };\n  const localCollapse = useMemo(() => {\n    if (!props.onCollapse) return undefined;\n    return () => props.onCollapse?.(props.item.id);\n  }, [props.item.id, props.onCollapse]);\n\n  const localRemove = useMemo(() => {\n    if (!props.onRemove) return undefined;\n\n    return () => props.onRemove?.(props.item.id);\n  }, [props.item.id, props.onRemove]);\n  return (\n    <TreeItemComponent\n      {...props}\n      ref={setDraggableNodeRef}\n      wrapperRef={setDroppableNodeRef}\n      style={keepGhostInPlace ? undefined : style}\n      depth={depth}\n      ghost={isDragging}\n      disableSelection={iOS}\n      disableInteraction={isSorting}\n      isLast={isLast}\n      parent={parent}\n      handleProps={{\n        ...attributes,\n        ...listeners,\n      }}\n      onCollapse={localCollapse}\n      onRemove={localRemove}\n      disableSorting={disableSorting}\n      isOver={isOver}\n      isOverParent={isOverParent}\n    />\n  );\n};\n\nexport const SortableTreeItem = React.memo(\n  SortableTreeItemNotMemoized\n) as typeof SortableTreeItemNotMemoized;\n","import React, {\r\n  useCallback,\r\n  useEffect,\r\n  useMemo,\r\n  useRef,\r\n  useState,\r\n} from 'react';\r\nimport { createPortal } from 'react-dom';\r\nimport {\r\n  Announcements,\r\n  closestCenter,\r\n  defaultDropAnimation,\r\n  DndContext,\r\n  DragEndEvent,\r\n  DragMoveEvent,\r\n  DragOverEvent,\r\n  DragOverlay,\r\n  DragStartEvent,\r\n  DropAnimation,\r\n  // MeasuringStrategy,\r\n  // KeyboardSensor,\r\n  Modifier,\r\n  PointerSensor,\r\n  PointerSensorOptions,\r\n  UniqueIdentifier,\r\n  useSensor,\r\n  useSensors,\r\n} from '@dnd-kit/core';\r\nimport { CSS } from '@dnd-kit/utilities';\r\nimport {\r\n  arrayMove,\r\n  SortableContext,\r\n  UseSortableArguments,\r\n} from '@dnd-kit/sortable';\r\n\r\nimport {\r\n  buildTree,\r\n  findItemDeep,\r\n  flattenTree,\r\n  getChildCount,\r\n  getProjection,\r\n  removeChildrenOf,\r\n  removeItem,\r\n  setProperty,\r\n} from './utilities';\r\nimport type {\r\n  FlattenedItem,\r\n  ItemChangedReason,\r\n  SensorContext,\r\n  TreeItemComponentType,\r\n  TreeItems,\r\n} from './types';\r\n// import { sortableTreeKeyboardCoordinates } from './keyboardCoordinates';\r\nimport { SortableTreeItem } from './SortableTreeItem';\r\nimport { customListSortingStrategy } from './SortingStrategy';\r\n\r\nexport type SortableTreeProps<\r\n  TData extends Record<string, any>,\r\n  TElement extends HTMLElement\r\n> = {\r\n  items: TreeItems<TData>;\r\n  onItemsChanged(\r\n    items: TreeItems<TData>,\r\n    reason: ItemChangedReason<TData>\r\n  ): void;\r\n  TreeItemComponent: TreeItemComponentType<TData, TElement>;\r\n  indentationWidth?: number;\r\n  indicator?: boolean;\r\n  pointerSensorOptions?: PointerSensorOptions;\r\n  disableSorting?: boolean;\r\n  dropAnimation?: DropAnimation | null;\r\n  dndContextProps?: React.ComponentProps<typeof DndContext>;\r\n  sortableProps?: Omit<UseSortableArguments, 'id'>;\r\n  keepGhostInPlace?: boolean;\r\n  canRootHaveChildren?: boolean | ((dragItem: FlattenedItem<TData>) => boolean);\r\n};\r\nconst defaultPointerSensorOptions: PointerSensorOptions = {\r\n  activationConstraint: {\r\n    distance: 3,\r\n  },\r\n};\r\n\r\nexport const dropAnimationDefaultConfig: DropAnimation = {\r\n  keyframes({ transform }) {\r\n    return [\r\n      { opacity: 1, transform: CSS.Transform.toString(transform.initial) },\r\n      {\r\n        opacity: 0,\r\n        transform: CSS.Transform.toString({\r\n          ...transform.final,\r\n          x: transform.final.x + 5,\r\n          y: transform.final.y + 5,\r\n        }),\r\n      },\r\n    ];\r\n  },\r\n  easing: 'ease-out',\r\n  sideEffects({ active }) {\r\n    active.node.animate([{ opacity: 0 }, { opacity: 1 }], {\r\n      duration: defaultDropAnimation.duration,\r\n      easing: defaultDropAnimation.easing,\r\n    });\r\n  },\r\n};\r\n\r\nexport function SortableTree<\r\n  TreeItemData extends Record<string, any>,\r\n  TElement extends HTMLElement = HTMLDivElement\r\n>({\r\n  items,\r\n  indicator,\r\n  indentationWidth = 20,\r\n  onItemsChanged,\r\n  TreeItemComponent,\r\n  pointerSensorOptions,\r\n  disableSorting,\r\n  dropAnimation,\r\n  dndContextProps,\r\n  sortableProps,\r\n  keepGhostInPlace,\r\n  canRootHaveChildren,\r\n  ...rest\r\n}: SortableTreeProps<TreeItemData, TElement>) {\r\n  const [activeId, setActiveId] = useState<UniqueIdentifier | null>(null);\r\n  const [overId, setOverId] = useState<UniqueIdentifier | null>(null);\r\n  const [offsetLeft, setOffsetLeft] = useState(0);\r\n  const [currentPosition, setCurrentPosition] = useState<{\r\n    parentId: UniqueIdentifier | null;\r\n    overId: UniqueIdentifier;\r\n  } | null>(null);\r\n\r\n  const flattenedItems = useMemo(() => {\r\n    const flattenedTree = flattenTree(items);\r\n    const collapsedItems = flattenedTree.reduce<UniqueIdentifier[]>(\r\n      (acc, { children, collapsed, id }) =>\r\n        collapsed && children?.length ? [...acc, id] : acc,\r\n      []\r\n    );\r\n\r\n    const result = removeChildrenOf(\r\n      flattenedTree,\r\n      activeId ? [activeId, ...collapsedItems] : collapsedItems\r\n    );\r\n    return result;\r\n  }, [activeId, items]);\r\n  const projected = getProjection(\r\n    flattenedItems,\r\n    activeId,\r\n    overId,\r\n    offsetLeft,\r\n    indentationWidth,\r\n    keepGhostInPlace ?? false,\r\n    canRootHaveChildren\r\n  );\r\n  const sensorContext: SensorContext<TreeItemData> = useRef({\r\n    items: flattenedItems,\r\n    offset: offsetLeft,\r\n  });\r\n  // const [coordinateGetter] = useState(() =>\r\n  //   sortableTreeKeyboardCoordinates(sensorContext, indentationWidth)\r\n  // );\r\n  const sensors = useSensors(\r\n    useSensor(\r\n      PointerSensor,\r\n      pointerSensorOptions ?? defaultPointerSensorOptions\r\n    )\r\n    // useSensor(KeyboardSensor, {\r\n    //   coordinateGetter,\r\n    // })\r\n  );\r\n\r\n  const sortedIds = useMemo(\r\n    () => flattenedItems.map(({ id }) => id),\r\n    [flattenedItems]\r\n  );\r\n  const activeItem = activeId\r\n    ? flattenedItems.find(({ id }) => id === activeId)\r\n    : null;\r\n\r\n  useEffect(() => {\r\n    sensorContext.current = {\r\n      items: flattenedItems,\r\n      offset: offsetLeft,\r\n    };\r\n  }, [flattenedItems, offsetLeft]);\r\n\r\n  const itemsRef = useRef(items);\r\n  itemsRef.current = items;\r\n  const handleRemove = useCallback(\r\n    (id: string) => {\r\n      const item = findItemDeep(itemsRef.current, id)!;\r\n      onItemsChanged(removeItem(itemsRef.current, id), {\r\n        type: 'removed',\r\n        item,\r\n      });\r\n    },\r\n    [onItemsChanged]\r\n  );\r\n\r\n  const handleCollapse = useCallback(\r\n    function handleCollapse(id: string) {\r\n      const item = findItemDeep(itemsRef.current, id)!;\r\n      onItemsChanged(\r\n        setProperty(itemsRef.current, id, 'collapsed', ((value: boolean) => {\r\n          return !value;\r\n        }) as any),\r\n        {\r\n          type: item.collapsed ? 'collapsed' : 'expanded',\r\n          item: item,\r\n        }\r\n      );\r\n    },\r\n    [onItemsChanged]\r\n  );\r\n\r\n  const announcements: Announcements = useMemo(\r\n    () => ({\r\n      onDragStart({ active }) {\r\n        return `Picked up ${active.id}.`;\r\n      },\r\n      onDragMove({ active, over }) {\r\n        return getMovementAnnouncement('onDragMove', active.id, over?.id);\r\n      },\r\n      onDragOver({ active, over }) {\r\n        return getMovementAnnouncement('onDragOver', active.id, over?.id);\r\n      },\r\n      onDragEnd({ active, over }) {\r\n        return getMovementAnnouncement('onDragEnd', active.id, over?.id);\r\n      },\r\n      onDragCancel({ active }) {\r\n        return `Moving was cancelled. ${active.id} was dropped in its original position.`;\r\n      },\r\n    }),\r\n    []\r\n  );\r\n\r\n  const strategyCallback = useCallback(() => {\r\n    return !!projected;\r\n  }, [projected]);\r\n  return (\r\n    <DndContext\r\n      accessibility={{ announcements }}\r\n      sensors={disableSorting ? undefined : sensors}\r\n      modifiers={indicator ? modifiersArray : undefined}\r\n      collisionDetection={closestCenter}\r\n      // measuring={measuring}\r\n      onDragStart={disableSorting ? undefined : handleDragStart}\r\n      onDragMove={disableSorting ? undefined : handleDragMove}\r\n      onDragOver={disableSorting ? undefined : handleDragOver}\r\n      onDragEnd={disableSorting ? undefined : handleDragEnd}\r\n      onDragCancel={disableSorting ? undefined : handleDragCancel}\r\n      {...dndContextProps}\r\n    >\r\n      <SortableContext\r\n        items={sortedIds}\r\n        strategy={\r\n          disableSorting\r\n            ? undefined\r\n            : customListSortingStrategy(strategyCallback)\r\n        }\r\n      >\r\n        {flattenedItems.map((item) => {\r\n          return (\r\n            <SortableTreeItem\r\n              {...rest}\r\n              key={item.id}\r\n              id={item.id as any}\r\n              item={item}\r\n              childCount={item.children?.length}\r\n              depth={\r\n                item.id === activeId && projected && !keepGhostInPlace\r\n                  ? projected.depth\r\n                  : item.depth\r\n              }\r\n              indentationWidth={indentationWidth}\r\n              indicator={indicator}\r\n              collapsed={Boolean(item.collapsed && item.children?.length)}\r\n              onCollapse={item.children?.length ? handleCollapse : undefined}\r\n              onRemove={handleRemove}\r\n              isLast={\r\n                item.id === activeId && projected\r\n                  ? projected.isLast\r\n                  : item.isLast\r\n              }\r\n              parent={\r\n                item.id === activeId && projected\r\n                  ? projected.parent\r\n                  : item.parent\r\n              }\r\n              TreeItemComponent={TreeItemComponent}\r\n              disableSorting={disableSorting}\r\n              sortableProps={sortableProps}\r\n              keepGhostInPlace={keepGhostInPlace}\r\n            />\r\n          );\r\n        })}\r\n        {createPortal(\r\n          <DragOverlay\r\n            dropAnimation={\r\n              dropAnimation === undefined\r\n                ? dropAnimationDefaultConfig\r\n                : dropAnimation\r\n            }\r\n          >\r\n            {activeId && activeItem ? (\r\n              <TreeItemComponent\r\n                {...rest}\r\n                item={activeItem}\r\n                children={[]}\r\n                depth={activeItem.depth}\r\n                clone\r\n                childCount={getChildCount(items, activeId) + 1}\r\n                indentationWidth={indentationWidth}\r\n                isLast={false}\r\n                parent={activeItem.parent}\r\n                isOver={false}\r\n                isOverParent={false}\r\n              />\r\n            ) : null}\r\n          </DragOverlay>,\r\n          document.body\r\n        )}\r\n      </SortableContext>\r\n    </DndContext>\r\n  );\r\n\r\n  function handleDragStart({ active: { id: activeId } }: DragStartEvent) {\r\n    setActiveId(activeId);\r\n    setOverId(activeId);\r\n\r\n    const activeItem = flattenedItems.find(({ id }) => id === activeId);\r\n\r\n    if (activeItem) {\r\n      setCurrentPosition({\r\n        parentId: activeItem.parentId,\r\n        overId: activeId,\r\n      });\r\n    }\r\n\r\n    document.body.style.setProperty('cursor', 'grabbing');\r\n  }\r\n\r\n  function handleDragMove({ delta }: DragMoveEvent) {\r\n    setOffsetLeft(delta.x);\r\n  }\r\n\r\n  function handleDragOver({ over }: DragOverEvent) {\r\n    setOverId(over?.id ?? null);\r\n  }\r\n\r\n  function handleDragEnd({ active, over }: DragEndEvent) {\r\n    resetState();\r\n\r\n    if (projected && over) {\r\n      const { depth, parentId } = projected;\r\n      if (keepGhostInPlace && over.id === active.id) return;\r\n      const clonedItems: FlattenedItem<TreeItemData>[] = flattenTree(items);\r\n      const overIndex = clonedItems.findIndex(({ id }) => id === over.id);\r\n      const activeIndex = clonedItems.findIndex(({ id }) => id === active.id);\r\n      const activeTreeItem = clonedItems[activeIndex];\r\n\r\n      clonedItems[activeIndex] = { ...activeTreeItem, depth, parentId };\r\n      const draggedFromParent = activeTreeItem.parent;\r\n      const sortedItems = arrayMove(clonedItems, activeIndex, overIndex);\r\n      const newItems = buildTree(sortedItems);\r\n      const newActiveItem = sortedItems.find((x) => x.id === active.id)!;\r\n      const currentParent = newActiveItem.parentId\r\n        ? sortedItems.find((x) => x.id === newActiveItem.parentId)!\r\n        : null;\r\n      // removing setTimeout leads to an unwanted scrolling\r\n      // Use case:\r\n      //   There are a lot of items in a tree (so that the scroll exists).\r\n      //   You take the node from the bottom and move it to the top\r\n      //   Without `setTimeout` when you drop the node the list gets scrolled to the bottom.\r\n      setTimeout(() =>\r\n        onItemsChanged(newItems, {\r\n          type: 'dropped',\r\n          draggedItem: newActiveItem,\r\n          draggedFromParent: draggedFromParent,\r\n          droppedToParent: currentParent,\r\n        })\r\n      );\r\n    }\r\n  }\r\n\r\n  function handleDragCancel() {\r\n    resetState();\r\n  }\r\n\r\n  function resetState() {\r\n    setOverId(null);\r\n    setActiveId(null);\r\n    setOffsetLeft(0);\r\n    setCurrentPosition(null);\r\n\r\n    document.body.style.setProperty('cursor', '');\r\n  }\r\n\r\n  function getMovementAnnouncement(\r\n    eventName: string,\r\n    activeId: UniqueIdentifier,\r\n    overId?: UniqueIdentifier\r\n  ) {\r\n    if (overId && projected) {\r\n      if (eventName !== 'onDragEnd') {\r\n        if (\r\n          currentPosition &&\r\n          projected.parentId === currentPosition.parentId &&\r\n          overId === currentPosition.overId\r\n        ) {\r\n          return;\r\n        } else {\r\n          setCurrentPosition({\r\n            parentId: projected.parentId,\r\n            overId,\r\n          });\r\n        }\r\n      }\r\n\r\n      const clonedItems: FlattenedItem<TreeItemData>[] = flattenTree(items);\r\n      const overIndex = clonedItems.findIndex(({ id }) => id === overId);\r\n      const activeIndex = clonedItems.findIndex(({ id }) => id === activeId);\r\n      const sortedItems = arrayMove(clonedItems, activeIndex, overIndex);\r\n\r\n      const previousItem = sortedItems[overIndex - 1];\r\n\r\n      let announcement;\r\n      const movedVerb = eventName === 'onDragEnd' ? 'dropped' : 'moved';\r\n      const nestedVerb = eventName === 'onDragEnd' ? 'dropped' : 'nested';\r\n\r\n      if (!previousItem) {\r\n        const nextItem = sortedItems[overIndex + 1];\r\n        announcement = `${activeId} was ${movedVerb} before ${nextItem.id}.`;\r\n      } else {\r\n        if (projected.depth > previousItem.depth) {\r\n          announcement = `${activeId} was ${nestedVerb} under ${previousItem.id}.`;\r\n        } else {\r\n          let previousSibling: FlattenedItem<TreeItemData> | undefined =\r\n            previousItem;\r\n          while (previousSibling && projected.depth < previousSibling.depth) {\r\n            const parentId: UniqueIdentifier | null = previousSibling.parentId;\r\n            previousSibling = sortedItems.find(({ id }) => id === parentId);\r\n          }\r\n\r\n          if (previousSibling) {\r\n            announcement = `${activeId} was ${movedVerb} after ${previousSibling.id}.`;\r\n          }\r\n        }\r\n      }\r\n\r\n      return announcement;\r\n    }\r\n\r\n    return;\r\n  }\r\n}\r\n\r\nconst adjustTranslate: Modifier = ({ transform }) => {\r\n  return {\r\n    ...transform,\r\n    y: transform.y - 25,\r\n  };\r\n};\r\nconst modifiersArray = [adjustTranslate];\r\n","import {\n  SortingStrategy,\n  verticalListSortingStrategy,\n} from '@dnd-kit/sortable';\nexport const customListSortingStrategy = (\n  isValid: (activeIndex: any, overIndex: any) => boolean\n): SortingStrategy => {\n  const sortingStrategy: SortingStrategy = ({\n    activeIndex,\n    activeNodeRect,\n    index,\n    rects,\n    overIndex,\n  }) => {\n    if (isValid(activeIndex, overIndex)) {\n      return verticalListSortingStrategy({\n        activeIndex,\n        activeNodeRect,\n        index,\n        rects,\n        overIndex,\n      });\n    }\n    return null;\n  };\n  return sortingStrategy;\n};\n"],"names":["styleInject","css","ref","insertAt","document","head","getElementsByTagName","style","createElement","type","firstChild","insertBefore","appendChild","styleSheet","cssText","createTextNode","SimpleTreeItemWrapper","forwardRef","props","clone","depth","disableSelection","disableInteraction","disableSorting","ghost","handleProps","indentationWidth","indicator","collapsed","onCollapse","onRemove","wrapperRef","hideCollapseButton","childCount","manualDrag","showDragHandle","disableCollapseOnItemClick","isLast","className","contentClassName","rest","React","clsx","paddingLeft","undefined","onClick","e","preventDefault","children","FolderTreeItemWrapper","parent","flattenedParents","flattenParents","map","item","key","id","iOS","window","test","navigator","platform","_revertLastChanges","flattenTree","items","flatten","parentId","reduce","acc","index","flattenedItem","length","findItem","itemId","find","findItemDeep","child","getChildCount","countChildren","count","animateLayoutChanges","isSorting","isDragging","SortableTreeItemNotMemoized","TreeItemComponent","sortableProps","keepGhostInPlace","useSortable","disabled","attributes","listeners","setDraggableNodeRef","setDroppableNodeRef","transform","transition","isOver","over","isOverParent","useMemo","getIsOverParent","overId","CSS","Translate","toString","localCollapse","localRemove","SortableTreeItem","memo","defaultPointerSensorOptions","activationConstraint","distance","dropAnimationDefaultConfig","keyframes","opacity","Transform","initial","x","y","easing","sideEffects","active","node","animate","duration","defaultDropAnimation","modifiersArray","onItemsChanged","pointerSensorOptions","dropAnimation","dndContextProps","canRootHaveChildren","useState","activeId","setActiveId","setOverId","offsetLeft","setOffsetLeft","currentPosition","setCurrentPosition","flattenedItems","flattenedTree","collapsedItems","ids","excludeParentIds","filter","includes","_item$children5","push","removeChildrenOf","projected","dragOffset","overItemIndex","findIndex","activeItemIndex","activeItem","findParentWhichCanHaveChildren","_parent2","_parent3","_parent4","newItems","arrayMove","previousItem","nextItem","dragDepth","offset","Math","round","getDragDepth","findParentWithDepth","maxDepth","minDepth","newParent","slice","reverse","_newItems$slice$rever","getParentId","dragItem","canHaveChildren","getProjection","sensorContext","useRef","sensors","useSensors","useSensor","PointerSensor","sortedIds","useEffect","current","itemsRef","isValid","handleRemove","useCallback","removeItem","_item$children2","handleCollapse","setProperty","property","setter","_item$children3","value","announcements","onDragStart","onDragMove","getMovementAnnouncement","onDragOver","onDragEnd","onDragCancel","strategyCallback","DndContext","accessibility","modifiers","collisionDetection","closestCenter","body","delta","resetState","clonedItems","overIndex","activeIndex","activeTreeItem","draggedFromParent","sortedItems","root","nodes","buildTree","newActiveItem","currentParent","setTimeout","draggedItem","droppedToParent","SortableContext","strategy","activeNodeRect","rects","verticalListSortingStrategy","_item$children","Boolean","createPortal","DragOverlay","eventName","announcement","movedVerb","previousSibling"],"mappings":"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"}